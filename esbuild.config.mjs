import builtins from "builtin-modules";
import { build } from "esbuild";
import { lessLoader } from "esbuild-plugin-less";
import { promises } from "fs";
const { copyFile, rename, writeFile, readFile } = promises;

const banner = `/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source visit the plugins github repository
*/
`;

/** @type import("esbuild").Plugin */
const obPlugin = {
  name: "obsidian-plugin",
  setup: (build) => {
    build.onEnd(async () => {
      // fix default css output file name
      const { outfile } = build.initialOptions;
      try {
        await rename(
          outfile.replace(/\.js$/, ".css"),
          outfile.replace(/main\.js$/, "styles.css"),
        );
      } catch (err) {
        if (err.code !== "ENOENT") throw err;
      }

      // copy manifest.json to build dir
      await copyFile("manifest.json", "build/manifest.json");

      // create .hotreload if it doesn't exist
      try {
        await writeFile("build/.hotreload", "", { flag: "wx" });
      } catch (err) {
        if (err.code !== "EEXIST") throw err;
      }

      console.log("build finished");
    });
  },
};

const NODE_SQLITE3 = `"__NODE_SQLITE3_NATIVE_PATCH__"`;
const PATH_TO_CONFIG = `app.vault.adapter.getFullPath(app.vault.configDir)`;
const LIB_ROOT = "node-sqlite3";

/** @type import("esbuild").Plugin */
const patchNodePreGypForSQL = {
  name: "patch-node-pre-gyp",
  setup: (build) => {
    build.onLoad(
      {
        filter: /node_modules\/node-pre-gyp\/lib\/pre-binding\.js$/,
      },
      async (args) => {
        let original = await readFile(args.path, "utf8");
        original = original
          .replace(
            `   if (!existsSync(package_json_path)) {
        throw new Error("package.json does not exist at " + package_json_path);
   }`,
            "",
          )
          .replace(
            "require(package_json_path)",
            `package_json_path === ${NODE_SQLITE3} ? require("../../sqlite3/package.json") : {}`,
          )
          .replace(
            `opts.module_root = path.dirname(package_json_path)`,
            `opts.module_root = ${PATH_TO_CONFIG}`,
          );
        return { contents: original };
      },
    );
    build.onLoad(
      {
        filter: /node_modules\/sqlite3\/lib\/sqlite3-binding\.js$/,
      },
      async (args) => {
        // run check and show dialog before calling binding
        // and throw error if lib not installed
        const checkLib = `require("${process.cwd()}/check-lib")(${PATH_TO_CONFIG}, "${LIB_ROOT}");`;
        let original = await readFile(args.path, "utf8");
        original = original.replace(
          `path.resolve(path.join(__dirname,'../package.json'))`,
          NODE_SQLITE3,
        );
        return { contents: checkLib + original };
      },
    );
    build.onLoad(
      {
        filter: /sqlite3\/package\.json$/,
      },
      async (args) => {
        let original = JSON.parse(await readFile(args.path, "utf8"));
        original.binary.module_path = original.binary.module_path.replace(
          "lib/binding",
          LIB_ROOT,
        );
        return { contents: JSON.stringify(original), loader: "json" };
      },
    );
  },
};

const isProd = process.env.BUILD === "production";

try {
  await build({
    entryPoints: ["src/zt-main.ts"],
    bundle: true,
    watch: !isProd,
    platform: "browser",
    external: ["obsidian", "electron", ...builtins],
    format: "cjs",
    mainFields: ["browser", "module", "main"],
    banner: { js: banner },
    sourcemap: isProd ? false : "inline",
    minify: isProd,
    define: {
      "process.env.NODE_ENV": JSON.stringify(process.env.BUILD),
    },
    outfile: "build/main.js",
    plugins: [lessLoader(), obPlugin, patchNodePreGypForSQL],
  });
} catch (err) {
  console.error(err);
  process.exit(1);
}
